# 오류 처리

- 깨끗한 코드와 오류 처리는 확실히 연관성이 있다 
- 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다. 

## 오류 코드보다 예외를 사용하라
- 함수를 호출한 즉시 오류 처리 코드를 보게 되면 단계를 잊어 버리기 쉬워진다. 
    - 그래서 오류가 발생하면 예외를 던지는 편이 낫다. 
    - 예외를 던지면 오류처리 코드와 뒤섞이지 않는다

## Try-Catch-Finally 문부터 작성하라
- try 블록은 트랜잭션과 비슷하다
    - try 블록에서 무슨 일이 생기든지 catch블록은 프로그램 상태를 일관성 있게 유지해야 한다. 
    - 그러므로 예외가 발생할 코드를 짤 때는 try catch finally 문의 시작하는 편이 낫다.
    - 그러면 try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다. 

## 미확인(unchecked) 예외를 사용하라
- 여러 해 동안 자바 프로그램은 확인된 예외의 장단점을 놓고 논쟁을 벌여 왔다. 
    - 자바 첫 버전이 확인된 예외를 선보였고 당시는 멋진 아이디어라 생각했다. 
        - 메서드를 선언할 때는 메서드가 반환할 예외를 모두 열거했다. 
    - 지금은 안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지는 않다는 사실이 분명해졌다
        - C#, c++, 파이썬,루비 은 확인된 예외를 지원하지 않는다. 
            - 그럼에도 위 언어는 안정적인 소프트웨어를 구현하기에 무리가 없다. 
- 확인된 예외는 OCP(Open Close Principle)을 위반한다. 
    - 메서드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메서드 모드가 선언부에 해당 예외를 정의해야 한다. 
    - 최하위 함수를 변경해 새로운 오류를 던진다면 변경한 함수를 호출하는 모든 함수가 catch블록에서 새로운 예외를 처리하거나 선언부에 throw 절을 추가해야 한다. 
    - 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다. 
- 모든 예외를 잡아야 한다면 확인된 예외도 유용하다.
- 하지만 일반적인 애플리케이션은 의존성이라는 비용이 이익보다 크다. 

## 예외에 의미를 제공하라
- 예외를 던질 때는 전후 상황을 충분히 덧붙인다. 
    - 그러면 오류가 발생한 원인과 위치를 찾기 쉬워진다. 
- 오류 메시지에 정보를 담아 예외와 함께 던진다.
    - 실패한 연산 이름과 유형도 언급한다. 
    - 로깅 기능을 사용한다면 catch블록에서 오류를 기록하도록 충분한 정보를 넘겨준다. 

## 호출자를 고려해 예외 클래스를 정의하라
- 오류를 분류하는 방법은 수없이 많다
    - 발생한 위치, 발생한 컴포넌트, 유형
- 오류를 정의할 때 가장 중요한 관심사는 `오류를 잡아내는 방법` 이 되어야 한다. 
- 우리가 오류룰 처리하는 방시은 비교적 일정하다
    1. 오류를 기록한다.
    2. 프로그램을 계속 수행해도 좋은지 확인한다.
- 실제로 외부 API를 사용할 때는 감싸기(Wrapper) 기법이 최선이다. 
    - 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다. 
    - 나중에 다른 라이브러리로 갈아타도 비용이 적다
    - 감싸기 클래스에서 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기도 쉬워진다. 
    - 특정 업체가 API를 설계한 방식에 발목 잡히지 않는다. 
- 흔히 예외 클래스가 하나만 있어도 충분한 코드가 많다. 
    - 예외 클래스에 포함된 정보로 오류를 구분해도 괜찮은 경우가 그렇다. 
    - 한 예외는 잡아내고 다른 예외는 무시해도 괜찮은 경우라면 여러 예외 클래스를 사용한다. 

## 정상 흐름을 정의하라. 
- 특수 상활을 처리하지 말고 클래스를 만들거나 객체를 조작해 특수사례를 처리하라
    - 특수 사례 패턴 Speacial case pattern

## null을 반환하지 마라.
- 흔히 저지르는 오류를 유발하는 행위
    - 한 줄 건너 하나씩 null을 확인하는 코드가 가득하게 된다. 
    - null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다. 
    - 누구 하나라도 null 확인을 빼먹는다면 애플리케이션이 통제 불능에 빠질지도 모른다. 
- 메서드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다. 
- 사용하려는 외부 API가 null을 반환 한다면 감싸기 메서드를 구현해 예외를 던지거나 특수 사례 객체를 반환하는 방식을 고려한다. 
    - ex) 빈 객체, emptyList등

## null을 전달하지 마라
- null을 전달하는 방식은 더 나쁘다. 
    - 정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다. 
- 대다수 프로그래밍 언어는 호출자가 실수로 null을 적절히 처리하는 방법이 없다. 
    - 그렇다면 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다. 

## 결론
- 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 
- 이 둘은 상충하는 목표가 아니다. 
- 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다. 유지보수성도 굿

    
